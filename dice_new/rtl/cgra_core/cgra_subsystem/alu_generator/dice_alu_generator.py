#!/usr/bin/env python3
"""
dice_alu_generator.py
Generates DPI-C (.c) and SystemVerilog (.sv) ALU models from YAML config.

Pipeline semantics:
  pipeline = 0 → combinational (output changes immediately)
  pipeline = 1 → 1-cycle latency
  pipeline = N ≥ 2 → N-cycle pipeline (delayed outputs)
"""

import sys, os, yaml, textwrap
from dataclasses import dataclass, field
from typing import List

# ------------------ Data model ------------------
@dataclass
class Op:
    name: str
    opcode: int
    c_impl: str
    pipeline: int = 0

@dataclass
class AluSpec:
    name: str
    num_inputs: int
    inputs_width: List[int]
    num_outputs: int
    outputs_width: List[int]
    ops: List[Op] = field(default_factory=list)

# ------------------ Parse config ------------------
def parse_config(path: str) -> AluSpec:
    with open(path, "r") as f:
        data = yaml.safe_load(f)
    name = str(data["name"])
    num_inputs = int(data["inputs"])
    num_outputs = int(data["outputs"])
    inputs_width = [int(x) for x in data["inputs_width"]]
    outputs_width = [int(x) for x in data["outputs_width"]]
    ops = [
        Op(
            name=str(op["name"]),
            opcode=int(op["opcode"]),
            c_impl=str(op["c_impl"]).strip(),
            pipeline=int(op.get("pipeline", 0))
        )
        for op in data["ops"]
    ]
    return AluSpec(name, num_inputs, inputs_width, num_outputs, outputs_width, ops)

# ------------------ Helpers ------------------
HEADER_SV = """\
`timescale 1ns/1ps
/*
 * AUTO-GENERATED by dice_alu_generator.py — DO NOT EDIT.
 * name: {name}
 * inputs: {num_inputs} widths: {inputs_width}
 * outputs: {num_outputs} widths: {outputs_width}
 */
"""

HEADER_C = """\
/*
 * AUTO-GENERATED C DPI model — DO NOT EDIT.
 * name: {name}
 */
"""

def mask_expr(width: int) -> str:
    return "(~0ULL)" if width >= 64 else f"((1ULL << {width}) - 1ULL)"

# ------------------ C file generation ------------------
def c_file_content(spec: AluSpec) -> str:
    defines = "\n".join([f"#define OPCODE_{op.name.upper()} 0x{op.opcode:X}" for op in spec.ops])
    in_args = ", ".join([f"uint64_t in{i}" for i in range(spec.num_inputs)])
    out_args = ", ".join([f"uint64_t* out{i}" for i in range(spec.num_outputs)])
    in_mask = ", ".join([mask_expr(w) for w in spec.inputs_width])
    out_mask = ", ".join([mask_expr(w) for w in spec.outputs_width])

    # Combinational switch
    comb_cases = []
    for op in spec.ops:
        comb_cases.append(
            f"    case OPCODE_{op.name.upper()}: {{\n"
            f"{textwrap.indent(op.c_impl, '        ')}\n"
            "        break;\n    }"
        )
    comb_body = "\n".join(comb_cases)
    comb_zero = " ".join([f"out[{i}] = 0ULL;" for i in range(spec.num_outputs)])
    comb_copy = " ".join([f"if (out{i}) *out{i} = (out[{i}] & out_mask[{i}]);" for i in range(spec.num_outputs)])

    # Sequential switch
    seq_cases = []
    for op in spec.ops:
        if op.pipeline >= 1:
            n = op.pipeline
            nm = op.name
            body = [
                f"static uint64_t {nm}_pipe_in[{n}][{spec.num_inputs}] = {{0}};",
                f"static int {nm}_valid[{n}] = {{0}};",
                f"for (int i={n-1}; i>0; --i) {{",
                f"  for (int j=0;j<{spec.num_inputs};++j) {nm}_pipe_in[i][j] = {nm}_pipe_in[i-1][j];",
                f"  {nm}_valid[i] = {nm}_valid[i-1];",
                "}",
                f"for (int j=0;j<{spec.num_inputs};++j) {nm}_pipe_in[0][j] = in[j];",
                f"{nm}_valid[0] = 1;",
                f"if ({nm}_valid[{n-1}]) {{",
                f"  uint64_t stage[{spec.num_inputs}];",
                f"  for (int j=0;j<{spec.num_inputs};++j) stage[j] = {nm}_pipe_in[{n-1}][j];",
                textwrap.indent(op.c_impl.replace('in[', 'stage['), '  '),
                "} else {",
            ] + [f"  out[{i}] = 0ULL;" for i in range(spec.num_outputs)] + ["}"]
        else:
            body = [op.c_impl]
        seq_cases.append(
            f"    case OPCODE_{op.name.upper()}: {{\n"
            f"{textwrap.indent(chr(10).join(body), '        ')}\n"
            "        break;\n    }"
        )
    seq_body = "\n".join(seq_cases)

    return HEADER_C.format(**spec.__dict__) + f"""
#include <stdint.h>

{defines}

#ifdef __cplusplus
extern "C" {{
#endif

void {spec.name}_eval_comb({in_args}, uint32_t opcode, {out_args}) {{
    uint64_t in[{spec.num_inputs}] = {{ {', '.join([f'in{i}' for i in range(spec.num_inputs)])} }};
    uint64_t out[{spec.num_outputs}] = {{0}};
    const uint64_t in_mask[{spec.num_inputs}] = {{ {in_mask} }};
    const uint64_t out_mask[{spec.num_outputs}] = {{ {out_mask} }};
    for (int i=0;i<{spec.num_inputs};++i) in[i] &= in_mask[i];
    switch (opcode) {{
{comb_body}
    default: {comb_zero} break;
    }}
    {comb_copy}
}}

void {spec.name}_cycle({in_args}, uint32_t opcode, {out_args}) {{
    uint64_t in[{spec.num_inputs}] = {{ {', '.join([f'in{i}' for i in range(spec.num_inputs)])} }};
    uint64_t out[{spec.num_outputs}] = {{0}};
    const uint64_t in_mask[{spec.num_inputs}] = {{ {in_mask} }};
    const uint64_t out_mask[{spec.num_outputs}] = {{ {out_mask} }};
    for (int i=0;i<{spec.num_inputs};++i) in[i] &= in_mask[i];
    switch (opcode) {{
{seq_body}
    default: {comb_zero} break;
    }}
    {comb_copy}
}}

#ifdef __cplusplus
}}
#endif
"""

# ------------------ SV package ------------------
def sv_pkg_content(spec: AluSpec) -> str:
    params = "\n".join(
        [f"  localparam int unsigned OPCODE_{op.name.upper()} = 32'h{op.opcode:X};"
         for op in spec.ops]
    )
    lat_cases = "\n".join(
        [f"      OPCODE_{op.name.upper()}: op_latency = {op.pipeline};" for op in spec.ops]
    )
    return HEADER_SV.format(**spec.__dict__) + f"""
package {spec.name}_pkg;
{params}

  function automatic int op_latency(input int unsigned op);
    case (op)
{lat_cases}
      default: op_latency = 0;
    endcase
  endfunction

endpackage
"""

# ------------------ SV module ------------------
def sv_module_content(spec: AluSpec) -> str:
    any_seq = any(op.pipeline >= 1 for op in spec.ops)
    dpi_args = ",\n    ".join(
        [f"input longint in{i}" for i in range(spec.num_inputs)]
        + ["input int unsigned opcode"]
        + [f"output longint out{i}" for i in range(spec.num_outputs)]
    )

    ports = []
    if any_seq:
        ports.append("input logic clk")
    for i, w in enumerate(spec.inputs_width):
        ports.append(f"input logic [{w-1}:0] in{i}")
    ports.append("input logic [31:0] opcode")
    for i, w in enumerate(spec.outputs_width):
        ports.append(f"output logic [{w-1}:0] out{i}")
    ports_decl = ",\n  ".join(ports)

    in_comb_assigns = "\n    ".join([f"_in_comb[{i}] = longint'(in{i});" for i in range(spec.num_inputs)])
    in_seq_assigns  = "\n    ".join([f"_in_seq[{i}] = longint'(in{i});" for i in range(spec.num_inputs)])

    if not any_seq:
        out_assigns = " ".join([f"out{i} = {spec.outputs_width[i]}'(_out[{i}]);" for i in range(spec.num_outputs)])
        return HEADER_SV.format(**spec.__dict__) + f"""
import {spec.name}_pkg::*;
import "DPI-C" context function void {spec.name}_eval_comb({dpi_args});

module {spec.name} (
  {ports_decl}
);
  longint _in_comb[{spec.num_inputs}];
  longint _out[{spec.num_outputs}];

  always_comb begin
    {in_comb_assigns}
    {spec.name}_eval_comb({', '.join([f'_in_comb[{i}]' for i in range(spec.num_inputs)])},
                          int'(opcode),
                          {', '.join([f'_out[{i}]' for i in range(spec.num_outputs)])});
    {out_assigns}
  end
endmodule
"""
    else:
        sel_assigns = "\n  ".join([
            f"assign out{i} = (op_latency(opcode)==0) ? {spec.outputs_width[i]}'(_comb[{i}]) : {spec.outputs_width[i]}'(_seq[{i}]);"
            for i in range(spec.num_outputs)
        ])
        return HEADER_SV.format(**spec.__dict__) + f"""
import {spec.name}_pkg::*;
import "DPI-C" context function void {spec.name}_eval_comb({dpi_args});
import "DPI-C" context function void {spec.name}_cycle({dpi_args});

module {spec.name} (
  {ports_decl}
);
  longint _in_comb[{spec.num_inputs}];
  longint _in_seq[{spec.num_inputs}];
  longint _comb[{spec.num_outputs}];
  longint _seq[{spec.num_outputs}];

  // Combinational
  always_comb begin
    {in_comb_assigns}
    {spec.name}_eval_comb({', '.join([f'_in_comb[{i}]' for i in range(spec.num_inputs)])},
                          int'(opcode),
                          {', '.join([f'_comb[{i}]' for i in range(spec.num_outputs)])});
  end

  // Sequential
  always_ff @(posedge clk) begin
    {in_seq_assigns}
    {spec.name}_cycle({', '.join([f'_in_seq[{i}]' for i in range(spec.num_inputs)])},
                      int'(opcode),
                      {', '.join([f'_seq[{i}]' for i in range(spec.num_outputs)])});
  end

  {sel_assigns}
endmodule
"""

# ------------------ Main ------------------
def main():
    if len(sys.argv) < 2:
        print("Usage: python3 dice_alu_generator.py <config.yaml> [output_dir]")
        sys.exit(1)
    cfg = parse_config(sys.argv[1])
    outdir = sys.argv[2] if len(sys.argv) >= 3 else "./output"
    os.makedirs(outdir, exist_ok=True)
    with open(f"{outdir}/{cfg.name}_pkg.sv", "w") as f:
        f.write(sv_pkg_content(cfg))
    with open(f"{outdir}/{cfg.name}.sv", "w") as f:
        f.write(sv_module_content(cfg))
    with open(f"{outdir}/{cfg.name}_dpi.c", "w") as f:
        f.write(c_file_content(cfg))

    # --- New JSON opcode map ---
    import json
    opcode_map = {op.name.upper(): op.opcode for op in cfg.ops}
    with open(f"{outdir}/{cfg.name}_opcodes.json", "w") as f:
        json.dump(opcode_map, f, indent=2)

    print(f"✅ Generated to {outdir}/")

if __name__ == "__main__":
    main()
