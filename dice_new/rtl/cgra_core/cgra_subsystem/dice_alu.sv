`timescale 1ns/1ps
/*
 * AUTO-GENERATED by dice_alu_generator.py â€” DO NOT EDIT.
 * name: dice_alu
 * inputs: 4 widths: [32, 32, 32, 1]
 * outputs: 2 widths: [32, 1]
 */

import dice_alu_pkg::*;
import "DPI-C" context function void dice_alu_eval_comb(input longint in0,
    input longint in1,
    input longint in2,
    input longint in3,
    input int unsigned opcode,
    output longint out0,
    output longint out1);
import "DPI-C" context function void dice_alu_cycle(input longint in0,
    input longint in1,
    input longint in2,
    input longint in3,
    input int unsigned opcode,
    output longint out0,
    output longint out1);

module dice_alu (
  input logic clk,
  input logic [31:0] in0,
  input logic [31:0] in1,
  input logic [31:0] in2,
  input logic [0:0] in3,
  input logic [31:0] opcode,
  output logic [31:0] out0,
  output logic [0:0] out1
);
  longint _in_comb[4];
  longint _in_seq[4];
  longint _comb[2];
  longint _seq[2];

  // Combinational
  always_comb begin
    _in_comb[0] = longint'(in0);
    _in_comb[1] = longint'(in1);
    _in_comb[2] = longint'(in2);
    _in_comb[3] = longint'(in3);
    dice_alu_eval_comb(_in_comb[0], _in_comb[1], _in_comb[2], _in_comb[3],
                          int'(opcode),
                          _comb[0], _comb[1]);
  end

  // Sequential
  always_ff @(posedge clk) begin
    _in_seq[0] = longint'(in0);
    _in_seq[1] = longint'(in1);
    _in_seq[2] = longint'(in2);
    _in_seq[3] = longint'(in3);
    dice_alu_cycle(_in_seq[0], _in_seq[1], _in_seq[2], _in_seq[3],
                      int'(opcode),
                      _seq[0], _seq[1]);
  end

  assign out0 = (op_latency(opcode)==0) ? 32'(_comb[0]) : 32'(_seq[0]);
  assign out1 = (op_latency(opcode)==0) ? 1'(_comb[1]) : 1'(_seq[1]);
endmodule
